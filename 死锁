###一、死锁出现截图：
*1、Linux：
![afaaf](https://cloud.githubusercontent.com/assets/22741656/20216716/284399e0-a857-11e6-996c-1294fa6734d0.png)

*2、Windows:
![asdada](https://cloud.githubusercontent.com/assets/22741656/20216748/449865bc-a857-11e6-886a-f3945da6ea96.png)

###二、死锁产生的4个必要条件：
  
1.互斥条件：一个资源每次只能被一个进程使用  
2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放  
3.不剥夺条件:进程已获得的资源，在未使用完之前，不能强行剥夺  
4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系
###三、对上述程序产生死锁的解释
当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程对object中所有其它synchronized同步代码块或同步方法的访问将被阻塞。在循环时，线程不断被循环创建，于是如果当某线程还在运行b.methodB（a），而新创建的线程需要执行，那么它无法获得资源，于是形成死锁。

